{"componentChunkName":"component---src-templates-detail-template-jsx","path":"/algorithm-fibonacci/","result":{"pageContext":{"previous":{"fields":{"slug":"/react-router-basic/"},"frontmatter":{"title":"React Router로 라우팅 하기"}},"node":{"html":"<p>가장 널리 알려진 알고리즘 중의 하나인 피보나치(Fibonacci) 알고리즘에 대해서 알아보겠습니다.</p>\n<h2 id=\"피보나치-수열\" style=\"position:relative;\"><a href=\"#%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98%EC%97%B4\" aria-label=\"피보나치 수열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>피보나치 수열</h2>\n<p>피보나치 수열에서는 첫 번째 항은 0, 두 번째 항은 1, 그 다음부터는 바로 전 두 항의 숫자의 합이 현재 항의 값이 됩니다.\n따라서 피보나치나 수열은 다음과 같은 모습을 가지게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span> <span class=\"token number\">21</span><span class=\"token punctuation\">,</span> <span class=\"token number\">34</span><span class=\"token punctuation\">,</span> <span class=\"token number\">55</span><span class=\"token punctuation\">,</span> <span class=\"token number\">89</span><span class=\"token punctuation\">,</span> <span class=\"token number\">144</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"재귀-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"재귀 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀 알고리즘</h2>\n<p>피보나치 수열을 구현하는 가장 흔한 알고리즘은 재귀(recursion)를 사용하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> n <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>fib<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\", \"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">0</span>, <span class=\"token number\">1</span>, <span class=\"token number\">1</span>, <span class=\"token number\">2</span>, <span class=\"token number\">3</span>, <span class=\"token number\">5</span>, <span class=\"token number\">8</span>, <span class=\"token number\">13</span>, <span class=\"token number\">21</span>, <span class=\"token number\">34</span>, <span class=\"token number\">55</span>, <span class=\"token number\">89</span>, <span class=\"token number\">144</span>, <span class=\"token number\">233</span>, <span class=\"token number\">377</span>, <span class=\"token number\">610</span>, <span class=\"token number\">987</span>, <span class=\"token number\">1597</span>, <span class=\"token number\">2584</span>, <span class=\"token number\">4181</span>,</code></pre></div>\n<p>이 재귀 알고리즘의 시간과 공간 복잡도는 모두 <code>O(2^N)</code>으로 매우 비효율적입니다.\n즉, 재귀 함수의 인자로 넘기는 숫자가 커지면 실행 시간이 비약적으로 증가하게 됩니다.\n프로그램을 실행하는 컴퓨터마다 다르겠지만, 이 재귀 함수에 30 이상의 값을 넘기면 실행 속도가 현저히 느려질 것입니다.</p>\n<p>재귀 함수가 어떻게 호출이 되는지 트리로 그려보면, 중복 계산이 상당히 많이 일어나는 것을 알 수 있습니다.\n예를 들어, <code>fib(5)</code>를 호출하면 <code>fib(3)</code>는 두 번, <code>fib(2)</code>는 세 번, <code>fib(1)</code>은 다섯 번이나 반복해서 호출됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fib(5) =&gt; 3 + 2 = 5\n    fib(4) =&gt; 2 + 1 = 3\n        fib(3) =&gt; 1 + 1 = 2\n            fib(2) =&gt; 1 + 0 = 1\n                fib(1) =&gt; 1\n                fib(0) =&gt; 0\n            fib(1) =&gt; 1\n        fib(2) =&gt; 1 + 0 = 1\n            fib(1) =&gt; 1\n            fib(0) =&gt; 0\n    fib(3) =&gt; 1 + 1 = 2\n        fib(2) =&gt; 1 + 0 = 1\n            fib(1) =&gt; 1\n            fib(0) =&gt; 0\n        fib(1) =&gt; 1</code></pre></div>\n<h2 id=\"반복-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%B0%98%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"반복 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>반복 알고리즘</h2>\n<p>재귀 알고리즘으로 작성된 프로그램은 많은 경우 스택(stack)을 이용하면 반복 알고리즘으로 전활할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    total <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">while</span> stack<span class=\"token punctuation\">:</span>\n        n <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n            total <span class=\"token operator\">+=</span> n\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> total</code></pre></div>\n<p>위 코드의 시간/공간 복잡도는 맨 처음에 작성한 재귀 함수와 동일하지만 스택오퍼플로우(stack overflow)를 방지할 수 있는 이점이 있습니다.</p>\n<h2 id=\"메모이제이션\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98\" aria-label=\"메모이제이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모이제이션</h2>\n<p>위 재귀 트리를 관찰해보면 결국 <code>fib(5)</code>를 계산하기 위해서 필요한 것은 <code>fib(4)</code>, <code>fib(3)</code>, <code>fib(2)</code>, <code>fib(1)</code>의 결과 값이라는 것을 알 수 있습니다.\n따라서, 이 결과 값을 어딘 가에 저장해놓고 재활용할 수 있다면 중복 계산을 피할 수 있을 것 입니다.\n흔히 이러한 프로그래밍 기법을 메모이제이션(memoization)이라고 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    memo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">helper</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> n <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> memo<span class=\"token punctuation\">:</span>\n            memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> helper<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> helper<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">return</span> helper<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 코드는 <code>memo</code> 변수에 사전(dictionary)을 할당해놓고, 각 숫자의 계산 결과를 저장해고 있습니다.\n주어진 숫자의 계산 결과가 사전에 저장되어 있지 않은 경우에만 재귀 호출을 하기 때문에 훨씬 효율적입니다.</p>\n<p>이 알고리즘은 시간과 공간 복잡도는 모두 <code>O(N)</code> 입니다.\n왜냐하면 함수 호출 횟수와 저장 데이터의 크기가 주어진 숫자에 비례하기 때문입니다.</p>\n<h2 id=\"최적-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"최적 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적 알고리즘</h2>\n<p>메모이제이션을 사용한 알고리즘의 성능도 나쁘지는 않지만 추가적인 공간 최적화를 해보도록 하겠습니다.\n피보나치 수열을 어떻게 계산되는지를 유심히 생각해보면 굳이 모든 수에 대한 계산 결과를 저장해둘 필요가 없다는 사실을 깨닫게 됩니다.\n왜냐하면 실제로 매 단계 필요한 것은 단지 전 단계와 바로 전전 단계의 계산 결과이기 때문입니다.\n결국, 두 개의 변수만 있다면 계속해서 매 단계 저장된 값을 바뀌가면서 재사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    p2<span class=\"token punctuation\">,</span> p1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        p2<span class=\"token punctuation\">,</span> p1 <span class=\"token operator\">=</span> p1<span class=\"token punctuation\">,</span> p2 <span class=\"token operator\">+</span> p1\n    <span class=\"token keyword\">return</span> p2</code></pre></div>\n<p>이 알고리즘은 고정된 크기의 메모리만 사용하므로 공간 복잡도가 <code>O(1)</code>이 됩니다.</p>","timeToRead":3,"fields":{"slug":"/algorithm-fibonacci/","tags":["algorithm","알고리즘","Python","파이썬"]},"frontmatter":{"title":"피보나치 알고리즘","date":"Jun 19, 2019"}},"next":{"fields":{"slug":"/react-font-awesome/"},"frontmatter":{"title":"React에서 Font Awesome 사용하기"}}}}}