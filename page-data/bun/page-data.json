{
    "componentChunkName": "component---src-templates-detail-template-jsx",
    "path": "/bun/",
    "result": {"pageContext":{"previous":{"fields":{"slug":"/python-set/"},"frontmatter":{"title":"파이썬 세트(set) 완벽 가이드"}},"node":{"html":"<p>최근에 번(Bun) v1.0이 출시되면서 차세대 자바스크립트 런타임(Runtime)으로 많은 기대를 한몸에 받고 있습니다.\n2023년 <a href=\"https://risingstars.js.org/2023/en#section-all\">JavaScript Rising Stars</a>에서도 Bun이 당당이 2위를 차지하였는데요.</p>\n<p>이번 포스팅에서는 귀여운 이름과 로고 뒤에 무시무시한 기능과 성능으로 무장하고 하고 있는 Bun이라는 새로운 자바스크립트 런타임에 대해서 살펴보겠습니다.</p>\n<p><img src=\"https://res.cloudinary.com/daleseo/image/upload/v1697325409/bun.jpg\" alt=\"Bun v1.0\"></p>\n<h2 id=\"자바스크립트-런타임\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%9F%B0%ED%83%80%EC%9E%84\" aria-label=\"자바스크립트 런타임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 런타임</h2>\n<p>Bun에 대해서 소개드리기 전에 먼저 자바스크립트 런타임(Runtime)이 무엇인지 가볍게 짚고 넘어가면 좋을 것 같아요.</p>\n<p>자바스크립트 런타임이란 쉽게 말해 자바스크립트로 작성된 프로그램을 실행해주는 소프트웨어를 의미합니다.\n가장 흔한 예로, 우리가 매일 사용하는 크롬이나 사파리, 파이어폭스, 엣지와 같은 웹 브라우저를 들 수 있죠.\n웹 브라우저는 HTML 문서에서 <code>&#x3C;script/></code> 태그를 통해 삽입된 자바스크립트 코드를 실행하여 웹페이지가 사용자와 상호작용할 수 있도록 도와줍니다.</p>\n<p>자바스크립트 초창기에는 자바스크립트로 작성된 코드는 브라우저를 통해서 클라이언트 측에만 실행할 수 있었습니다.\n그러나 2009년에 Node.js가 등장하면서 서버 측에도 자바스크립트 코드를 실행할 수 있는 길이 열리게 됩니다.\n다시 말해서, 프런트엔드뿐만 아니라 백엔드에서 자바크립트를 사용할 수 있게 된 것 인데요.\nNode.js는 C++로 개발되었으며, 그 이후에 Node.js 만드신 분이 Rust라는 새로운 언어로 Deno라는 또 다른 자바스크립트 런타임도 개발하기도 했죠.</p>\n<p>Bun은 Node.js와 Deno처럼 기본적으로 백엔드에서 사용하기 위해서 만들어진 자바스크립트 런타임이며,\nZig라는 아직 많은 분들에게 생소할 수도 있는 프로그래밍 언어로 개발이 되었습니다.</p>\n<p>참고로 하나의 프로그래밍 언어에 여러 개의 런타임이 있다는 것은 젼혀 이상한 현상이 아니에요.\n예를 들어, 파이썬(Python)에도 CPython, PyPy, Jython 등 다양한 런타임이 있고요,\n루비(Ruby)에도 MRI, JRuby, Rubinius 등 다양한 런타임이 있습니다.</p>\n<h2 id=\"bun-설치\" style=\"position:relative;\"><a href=\"#bun-%EC%84%A4%EC%B9%98\" aria-label=\"bun 설치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bun 설치</h2>\n<p>Bun은 MacOS와 같은 리눅스 계열 운영체제를 사용하고 계신다면 <code>curl</code> 명령어로 간편하게 설치해서 사용해볼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://bun.sh/install <span class=\"token operator\">|</span> <span class=\"token function\">bash</span></code></pre></div>\n<p>다음과 같이 터미널에서 Bun의 버전이 확인된다면 설치가 완료된 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun <span class=\"token parameter variable\">-v</span>\n<span class=\"token number\">1.0</span>.4</code></pre></div>\n<p>현재 제가 블로그를 쓰는 시점에서 윈도우즈 운영체제에서는 Bun을 온전하게 사용하기 어려운 상황이오니 참고 바라겠습니다.</p>\n<h2 id=\"bun-프로젝트-생성\" style=\"position:relative;\"><a href=\"#bun-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1\" aria-label=\"bun 프로젝트 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bun 프로젝트 생성</h2>\n<p>터미널에서 <code>bun init</code> 명령어를 실행하면 쉽게 Bun 프로젝트를 생성할 수 있는데요.\n패키지 이름과 진입 지점(entry point)를 대화형으로 물어보는데 귀찮으면 <code>-y</code> 옵션을 사용하면 됩니다.\n그러면 현재 폴더명이 패키지 이름으로 사용되고 <code>index.ts</code> 파일이 진입 지점이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun init <span class=\"token parameter variable\">-y</span>\nDone<span class=\"token operator\">!</span> A package.json <span class=\"token function\">file</span> was saved <span class=\"token keyword\">in</span> the current directory.\n + index.ts\n + .gitignore\n + tsconfig.json <span class=\"token punctuation\">(</span>for editor auto-complete<span class=\"token punctuation\">)</span>\n + README.md\n\nTo get started, run:\n  bun run index.ts</code></pre></div>\n<p>템플릿을 이용해서 Bun 프로젝트를 시작하고 싶다면 <code>bun create</code> 명령어를 사용할 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun create react-app</code></pre></div>\n<h2 id=\"타입스크립트-실행\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89\" aria-label=\"타입스크립트 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입스크립트 실행</h2>\n<p>Bun의 가장 큰 매력은 타입스크립트로 작성된 프로그램을 자바스크립트로 변환하지 않고 바로 실행할 수 있다는 것인데요.\n즉, Bun은 타입스크립트 런타임이라고도 부를 수도 있겟습니다.</p>\n<p>예를 들어, 아주 간단한 타입스크립트 프로그램을 작성해보겠습니다.</p>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"안녕하세요!\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>다음과 같이 이 프로그램 파일은 Bun을 통해서 터미널에서 바로 실행할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\n안녕하세요<span class=\"token operator\">!</span></code></pre></div>\n<p>만약에, 동일한 작업을 Node.js로 하려면 어떻게 했어야 했을까요?</p>\n<p>우선 타입스크립트로 작성된 프로그램을 <code>tsc</code> 커맨드로 컴파일(compile)했어야 겠죠?</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title\"><pre class=\"language-js:title\"><code class=\"language-js:title\">$ npx tsc index.ts</code></pre></div>\n<p>그래야지 결과물로 자바스크립트 파일을 얻을 수 있을테니까요.</p>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> message <span class=\"token operator\">=</span> <span class=\"token string\">\"안녕하세요!\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그 다음에 이 자바스크립트 프로그램을 Node.js로 실행했어야 했을 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">node</span> index.ts\n안녕하세요<span class=\"token operator\">!</span></code></pre></div>\n<blockquote>\n<p>타입스크립트 코드를 자바스크립트로 코드로 컴파일하는 기본적인 방법에 대해서는 <a href=\"/tsc/\">별도 포스팅</a>을 참고 바랍니다.</p>\n</blockquote>\n<p>물론, 이 두 단계의 작업을 한 번으로 줄여주는 <code>ts-node</code>나 <code>tsx</code>와 같은 개발 도구를 사용할 수도 있는데요.\n이 방법은 추가 패키지를 설치해줘야 한다는 나름의 귀찮음이 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-D</span> ts-node\n$ npx ts-node index.ts\n안녕하세요<span class=\"token operator\">!</span></code></pre></div>\n<p>Bun을 사용하면 이와 같은 번거로운 컴파일이나 개발 도구 설치가 필요 없어지기 때문에 개발 생산성이나 개발자 경험을 크게 향상시킬 수 있습니다.</p>\n<h2 id=\"모듈-시스템-호환성\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%98%B8%ED%99%98%EC%84%B1\" aria-label=\"모듈 시스템 호환성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈 시스템 호환성</h2>\n<p>현재 자바스크립트 생태계에서는 수년에 걸쳐 상당히 고통스러운 모듈 시스템의 전환 작업이 일어나고 있습니다.</p>\n<p>예전에는 모듈을 내보내거나 불러오기 위해서 Node.js를 중심으로 CJS(CommonJS)를 많이 사용했는데요.\n최근에는 ES6(ES2105)에서 ESM(ES Module)이라는 새로운 모듈 시스템이 표준으로 채택이 되면서, 신규 프로젝트에서는 ESM을 사용하는 것을 권장하는 분위기입니다.\n하지만 npm 패키지 저장소에는 10년을 훌쩍 넘는 기간동안 CommonJS을 사용한 패키지들이 축적되어 왔고,\n그 중 많은 오픈 소스 패키지는 더 이상 업데이트가 되지 않아서 ESM으로 언제 전환될지 알 수 없는 상황이죠.</p>\n<p>그러므로, 우리는 아직까지도 모듈을 내보니거나 불러올 때 CommonJS를 완전히 배제할 수 없는 상황인데요.\nESM 프로젝트에서 CJS 모듈을 불러오거나, 반대로 CJS 프로젝트에서 ESM 모듈을 불러올 때 갖가지 해결하기 까다로운 문제들이 발생할 수 있죠.</p>\n<blockquote>\n<p>자바스크립트의 모듈 시스템을 양분하고 있고 있는 CJS와 ESM에 대해서 더 궁금하시는 분들께는 다음 포스팅을 추천드리겠습니다.</p>\n<ul>\n<li><a href=\"/js-module-require/\">자바스크립트 CommonJS 모듈 내보내기/불러오기 (require)</a></li>\n<li><a href=\"/js-module-import/\">자바스크립트 ES 모듈 내보내기/불러오기</a></li>\n<li><a href=\"/js-node-es-modules/\">Node.js에서 ES 모듈(import/export) 사용하기</a></li>\n</ul>\n</blockquote>\n<p>하지만 Bun은 이렇게 골치 아플 수 있는 CJS와 ESM 간의 모듈 시스템 호환 문제를 런타임 수준에서 깔끔하게 해결해줍니다.</p>\n<p>예를 들어, 인자로 넘어온 메시지를 콘솔에 출력해주는 <code>hello()</code>라는 함수를 작성해보겠습니다.</p>\n<p><code>hello.cjs</code> 파일에는 CJS 방식으로 함수를 내보내겠습니다.</p>\n<div class=\"gatsby-code-title\">hello.cjs</div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">hello</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"CJS:\"</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code>hello.mjs</code> 파일에는 ESM 방식으로 함수를 내보내겠습니다.</p>\n<div class=\"gatsby-code-title\">hello.mjs</div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ESM:\"</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 <code>index.ts</code> 파일에서 작성한 함수를 불러와볼까요?</p>\n<p>우선 두 파일을 모두 ESM의 <code>import</code> 키워드를 사용하서 불러올 수 있습니다.</p>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hello.cjs\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\nCJS: 안녕하세요</code></pre></div>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hello.mjs\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\nESM: 안녕하세요</code></pre></div>\n<p>뿐만 아니라 두 파일을 모두 CJS의 <code>require</code> 키워드를 사용하서 불러올 수 있습니다.</p>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./hello.cjs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\nCJS: 안녕하세요</code></pre></div>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./hello.mjs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\nESM: 안녕하세요</code></pre></div>\n<p>더 놀라운 부분은 파일을 불러올 때 확장자를 명시하지 않으면, 똑똑하게 알아서 모듈 시스템에 맞는 파일을 선택해서 불러 온다는 것입니다.</p>\n<p>예를 들어, <code>import</code> 키워드를 썼을 때는, <code>hello.mjs</code> 파일에서 불러옵니다.</p>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\nESM: 안녕하세요</code></pre></div>\n<p>반면에 <code>require</code> 키워드를 썼을 때는, <code>hello.cjs</code> 파일에서 불러오는 것을 볼 수 있습니다.</p>\n<div class=\"gatsby-code-title\">index.ts</div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕하세요\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun index.ts\nCJS: 안녕하세요</code></pre></div>\n<h2 id=\"패키지-매니저-내장\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80-%EB%82%B4%EC%9E%A5\" aria-label=\"패키지 매니저 내장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패키지 매니저 내장</h2>\n<p>Node.js에서는 npm이 표준 패키지 매니저임에도 불구하고, Yarn이나 Pnpm과 같은 서드 파티 패키지 매니저도 많이 사용되고 있습니다.\n이렇게 다양한 패키지 매니저가 사용되는 이유는 아무래도 표준 패키지 매니저인 npm이 여러가지 부분에서 자바스크립트 커뮤니티의 기대에 부흥하지 못해서가 아닐까 싶은데요.\n물론 최근에 출시되고 있는 버전의 npm에서는 이렇게 부족한 부분이 많이 보완되어서 npm으로 회귀하는 프로젝트도 많아지고 있습니다.</p>\n<p>반면에, Bun은 아예 자체적으로 패키지 매니저를 내장하고 있으며, npm이나 Yarn과 같은 기존에 많이 사용되던 패키지 매니저랑 호환까지 됩니다.</p>\n<p>예를 들어, <code>package.json</code> 파일에 명시되어 있는 모든 패키지를 설치하고 싶다면 <code>bun install</code> 명령어를 실행하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">$ bun install</code></pre></div>\n<p>새로운 패키지를 추가하고 싶다면 <code>bun add</code> 명령어를 시용하면 되고요.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">$ bun add react</code></pre></div>\n<p>기존 패키지를 제거하고 싶다면 <code>bun remove</code> 명령어를 사용하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">$ bun remove react</code></pre></div>\n<p>명령줄 인터페이스(CLI)가 기존에 우리가 쓰던 패키지 매니저와 거의 동일하기 때문에 큰 이질감없이 사용할 수 있다는 장점이 있습니다.\n게다가 더 이상 어떤 패키지 매니저를 선택할지 고민할 필요도 없어지고요.</p>\n<h2 id=\"테스트-러너-내장\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%9F%AC%EB%84%88-%EB%82%B4%EC%9E%A5\" aria-label=\"테스트 러너 내장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 러너 내장</h2>\n<p>자바스크립트에서는 보통 테스트 코드를 실행할 때 <a href=\"/?tag=Jest\">Jest</a>와 같은 별도의 라이브러리를 사용하는데요.\n다른 프로그래밍 언어를 보면 런타임에서 테스트 러너(Runner)를 지원하는 경우가 많습니다.\n왜냐하면 테스트를 작성하고 실행하는 작업은 대부분의 소프트웨어 프로젝트에서 필수적이기 때문입니다.</p>\n<p>이러한 이유로 자바스크립트 런타임도 테스트 실행 기능과 관련 유틸리티를 내장하는 경우가 점점 늘어나고 있는데요.\nNode.js의 테스트 러너 API는 v20에서서 안정화가 되었고, Bun도 아예 처음부터 자체 테스트 러너를 내장하여 출시되었습니다.</p>\n<p><code>bun:test</code> 패키지를 통해서 테스트에 필요한 대부분의 유틸리티를 불러와서 사용할 수 있으며,</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> expect<span class=\"token punctuation\">,</span> test<span class=\"token punctuation\">,</span> spyOn <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"bun:test\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> hello <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> spy <span class=\"token operator\">=</span> <span class=\"token function\">spyOn</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">console</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"log\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"안녕?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>spy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toHaveBeenCalledTimes</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>spy<span class=\"token punctuation\">.</span>mock<span class=\"token punctuation\">.</span>calls<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toEqual</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"ESM:\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"안녕?\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>터미널에서 <code>bun test</code> 명령어를 통해서 작성한 테스트를 실행할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun <span class=\"token builtin class-name\">test</span>\nbun <span class=\"token builtin class-name\">test</span> v1.0.0 <span class=\"token punctuation\">(</span>822a00c4<span class=\"token punctuation\">)</span>\n\nhello.test.ts:\nESM: 안녕?\n✓ hello <span class=\"token punctuation\">[</span><span class=\"token number\">0</span>.35ms<span class=\"token punctuation\">]</span>\n\n <span class=\"token number\">1</span> pass\n <span class=\"token number\">0</span> fail\n <span class=\"token number\">2</span> expect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> calls\nRan <span class=\"token number\">1</span> tests across <span class=\"token number\">1</span> files. <span class=\"token punctuation\">[</span><span class=\"token number\">10</span>.00ms<span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"트랜스파일러번들러-내장\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%B2%88%EB%93%A4%EB%9F%AC-%EB%82%B4%EC%9E%A5\" aria-label=\"트랜스파일러번들러 내장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜스파일러/번들러 내장</h2>\n<p>그런데 Bun을 쓰면 항상 컴파일 과정을 생략할 수 있을까요?\n이 부분 오해하기 쉬운데요.\nBun을 쓰더라도 프론트엔드 프로젝트에서는 타입스크립트로 작성된 코드를 자바스크립트를 변환하는 작업은 필수입니다.\n왜냐하면 브라우저는 타입스크립트로 작성된 코드를 그대로 실행할 수 없기 때문입니다.</p>\n<p>하지만 Bun은 마치 타입스크립트처럼 JSX로 쓰여진 코드도 트랜스파일(transpile)없이 바로 처리할 수 있습니다.</p>\n<div class=\"gatsby-code-title\">Button.tsx</div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Button</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token attr-name\">message</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Hello world!<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-code-title\">Terminal</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ bun Button.ts\n<span class=\"token operator\">&lt;</span>Button <span class=\"token assign-left variable\">message</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello world!\"</span> /<span class=\"token operator\">></span></code></pre></div>\n<p>심지어 브라우저가 내려받아 실행해야 하는 자바스크립트 코드를 최적화하기 위해 번들러(bundler)까지 <code>bun build</code>라는 명령어를 통해 자체적으로 지원합니다.</p>\n<p>따라서 Bun 하나만 있으면, TypeScript나 Babel, Webpack과 같은 개발 도구가 없이도 웹사이트 배포를 위한 애플리케이션 빌드(build)를 처리할 수 있습니다.</p>\n<h2 id=\"web-표준-api-지원\" style=\"position:relative;\"><a href=\"#web-%ED%91%9C%EC%A4%80-api-%EC%A7%80%EC%9B%90\" aria-label=\"web 표준 api 지원 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web 표준 API 지원</h2>\n<p>Bun은 <code>fetch()</code>와 같은 Node.js가 다소 지원을 소홀히 하던 Web 표준 API도 적극적으로 지원하고 있습니다.\n엣지 컴퓨팅(Edge Computing)이나 SSR(서버 사이드 렌더링)과 같은 최신 웹 개발 트랜드를 충실히 반영하려는 노력이 엿보입니다.</p>\n<h2 id=\"bun의-뛰어난-성능\" style=\"position:relative;\"><a href=\"#bun%EC%9D%98-%EB%9B%B0%EC%96%B4%EB%82%9C-%EC%84%B1%EB%8A%A5\" aria-label=\"bun의 뛰어난 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bun의 뛰어난 성능</h2>\n<p>Bun의 <a href=\"https://bun.sh/\">웹사이트</a>를 방문해보시면 기존 자바스크립트 런타임 대비 작게는 몇 배 크게는 수십 배 성능이 빠르다는 문구나 도표를 이곳 저곳에서 쉽게 접할 수 있는데요.\n그만큼 Bun은 기능 뿐만 아니라 성능 측면에서도 매우 우수한 자바스크립트 런타임이라는 것을 알 수 있습니다.</p>\n<p><img src=\"https://res.cloudinary.com/daleseo/image/upload/v1697326472/bun-benchmark.png\" alt=\"Bun Benchmark\"></p>\n<h2 id=\"bun이-nodejs를-대체할까\" style=\"position:relative;\"><a href=\"#bun%EC%9D%B4-nodejs%EB%A5%BC-%EB%8C%80%EC%B2%B4%ED%95%A0%EA%B9%8C\" aria-label=\"bun이 nodejs를 대체할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bun이 Node.js를 대체할까?</h2>\n<p>Bun은 스스로를 Node.js의 완벽하게 대체할 수 있는 자바스크립트 런타임으로 마케팅하고 있는데요.\n하지만 Bun의 주장처럼 “a drop-in replacement for Node.js”, 즉 Node.js를 쓰고 있던 프로젝트에서 아무런 변경없이 바로 Bun을 사용해도 문제가 되지 않을 수준이 되기에는 아직 갈 길이 많이 남은 것으로 보입니다.\nNode.js 진영에서도 Bun은 Node.js를 대체할 수 없다고 맞불을 놓으며 여러 커뮤니티에서 신경전이 벌어지고 있는데요.</p>\n<p>과연 Bun이 Node.js를 대체할 수 있을까요?\n글쎄요… 거의 15년이 다 되어가는 Node.js의 아성을 Bun이 얼마나 빠른 시간에 무너뜨릴 수 있을지 의문입니다.\n2018년에 Deno가 처음 나왔을 때도 비슷한 기대와 논쟁이 있었지만 여전히 Node.js의 시장 점유율에 크게 미치치 못합니다.</p>\n<p>하지만 Bun은 Deno가 했던 실수들을 반복하지 않으며 처음부터 npm을 지원하고 Node.js와의 호환성을 최우선하고 있어서 개발자들 사이에서 아주 긍정적인 반응을 얻고 있습니다.\n뿐만 아니라, 커뮤니티 활동에 다소 인색한 Node.js에 비해, Bun의 커뮤니티는 매우 활발하게 사용자들 소통하고 있는 것으로 보입니다.</p>\n<p>기업 입장에서 특별히 현재 성능 이슈가 있지 않다면 단순히 Bun이 더 빠르다고 해서 오랫동안 안정성이 검증된 Node.js를 떠나기는 쉽지 않을 것입니다.\n아무래도 백엔드 서버의 런타임을 교체하는데는 적지 않은 위험 부담이 따르기 때문입니다.\n하지만 팀 단위로 진행되는 신규 프로젝트에서는 당장 Bun을 도입하여 개발 프로세스를 단순화하고 개발자 경험을 개선할 수도 있을 것 같습니다.\n개인 프로젝트에서는 Bun을 쓰지 않을 이유를 딱히 찾기 어려울 정도로 사용성이 좋은 것 같습니다.</p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>지금까지 차세대 자바스크립트 런타임으로 주목받고 있는 Bun에 대해서 알아보았습니다.</p>\n<p>컴파일, 테스트, 트랜스파일링, 번들링을 Bun 하나로 해결할 수 있으니 가히 올인원(All-in-one) 런타임이라고 불러도 손색이 없을 것 같습니다.\n이렇게 다양한 기능을 한 번에 제공하면서 성능도 기존의 다른 런타임을 압도할 수 있다니 정말 놀랍지 않나요?</p>\n<p>마지막으로 Bun의 등장을 너무 기존 런타임과의 경쟁 구도에서 바라 보실 필요는 없다라고 말씀드리고 싶은데요.\n저는 개인적으로 자바스크립트 생태계에 새로운 런타임이 생겼다는 것은 매우 반길만한 일이라고 생각합니다.\nNode.js와 Deno, Bun 그리고 앞으로 등장할 다른 런타임들이 서로의 좋은 점을 취하면서 선의의 경쟁을 펼칠테니까요.\n경쟁에서 어떤 런타임이 살아남고 도태되든, 자바스크립트 개발자들은 더 나은 개발 환경을 누릴 수 있겠죠?</p>\n<p>여러분들도 배워야 할 기술이 하나 더 늘었다고 너무 스트레스 받으시지 말고, 당장 쓰실 일은 없더라도 재미삼아 Bun을 한 번 직접 써보시기를 추천드리고 싶습니다. 😄</p>","timeToRead":10,"fields":{"slug":"/bun/","tags":["JavaScript","TypeScript","Bun"]},"frontmatter":{"title":"Bun: 귀엽지만 강력한 새로운 자바스크립트 런타임","date":"Oct 9, 2023"}},"next":{"fields":{"slug":"/nestjs-versioning/"},"frontmatter":{"title":"NestJS에서 API 버전 관리하기(Versioning)"}}}},
    "staticQueryHashes": ["2168229929","2362167539","3056348342"]}