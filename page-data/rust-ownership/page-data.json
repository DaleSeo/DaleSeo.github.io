{
    "componentChunkName": "component---src-templates-detail-template-jsx",
    "path": "/rust-ownership/",
    "result": {"pageContext":{"previous":null,"node":{"html":"<p>Rust를 처음 배우다 보면 컴파일러가 자꾸 “value moved here”나 “borrow of moved value” 같은 오류를 뱉어서 당황하게 됩니다.\n이런 오류들은 모두 Rust의 핵심 개념인 소유권(Ownership)과 관련이 있습니다.</p>\n<p>대부분의 프로그래밍 언어는 가비지 컬렉터(GC)를 통해 메모리를 관리하거나, C/C++처럼 프로그래머가 직접 메모리를 할당하고 해제해야 합니다.\nRust는 이 두 가지 방식 대신 소유권이라는 독특한 시스템을 사용하여 컴파일 시점에 메모리 안전성을 보장합니다.\nGC로 인한 성능 저하도 없고, 수동 메모리 관리로 인한 버그도 없는 셈이죠.</p>\n<p>이번 글에서는 Rust의 소유권 개념과 참조(References), 빌림(Borrowing)에 대해서 살펴보겠습니다.\n아직 Rust의 기본 자료형이 익숙하지 않다면 <a href=\"/rust-primitives/\">원시 자료형</a> 글을 먼저 읽어보시는 것을 권장합니다.</p>\n<h2 id=\"소유권이란\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%9C%A0%EA%B6%8C%EC%9D%B4%EB%9E%80\" aria-label=\"소유권이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소유권이란?</h2>\n<p>Rust에서 모든 값은 소유자(owner)라는 변수를 가집니다.\n소유권에는 세 가지 규칙이 있습니다.</p>\n<p>첫째, 각 값은 해당 값의 소유자인 변수를 가집니다.\n둘째, 한 번에 하나의 소유자만 존재할 수 있습니다.\n셋째, 소유자가 스코프를 벗어나면 값은 삭제(drop)됩니다.</p>\n<p>간단한 예제를 통해 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// s가 \"hello\"의 소유자</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{s}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 여기서 s가 스코프를 벗어나며 메모리가 해제됨</span></code></pre></div>\n<p>변수 <code>s</code>는 <code>String::from(\"hello\")</code>로 생성된 문자열의 소유자입니다.\n<code>main</code> 함수가 끝나면 <code>s</code>가 스코프를 벗어나고, Rust는 자동으로 해당 메모리를 해제합니다.\n이 과정을 drop이라고 부릅니다.</p>\n<h2 id=\"스택과-힙-메모리\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D%EA%B3%BC-%ED%9E%99-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"스택과 힙 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택과 힙 메모리</h2>\n<p>소유권을 제대로 이해하려면 스택(Stack)과 힙(Heap) 메모리의 차이를 알아야 합니다.</p>\n<p>스택에는 컴파일 시점에 크기가 정해진 데이터가 저장됩니다.\n정수, 부동소수점, 불리언, 고정 크기 배열 같은 타입들이 여기에 해당합니다.\n스택 데이터는 복사 비용이 저렴하기 때문에 변수에 할당하면 값이 복사(copy)됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token comment\">// x의 값이 복사되어 y에 저장됨</span>\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{x}, {y}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 둘 다 사용 가능</span></code></pre></div>\n<p>반면 힙에는 런타임에 크기가 결정되거나 변할 수 있는 데이터가 저장됩니다.\n<code>String</code>, <code>Vec</code>, <code>Box</code> 같은 타입들이 힙을 사용합니다.\n힙 데이터는 복사 비용이 크기 때문에 기본적으로 복사 대신 소유권이 이동(move)합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// s1의 소유권이 s2로 이동</span>\n<span class=\"token comment\">// println!(\"{s1}\"); // 오류! s1은 더 이상 유효하지 않음</span>\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{s2}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// s2만 사용 가능</span></code></pre></div>\n<p>스택에 저장되는 타입들은 <code>Copy</code> 트레이트를 구현하고 있어서 할당 시 자동으로 복사가 일어납니다.\n힙 데이터를 가진 타입들은 <code>Copy</code> 트레이트가 없어서 소유권 이동이 발생하는 것이죠.</p>\n<h2 id=\"소유권-이동-move\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%9C%A0%EA%B6%8C-%EC%9D%B4%EB%8F%99-move\" aria-label=\"소유권 이동 move permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소유권 이동 (Move)</h2>\n<p>소유권 이동은 변수 할당뿐만 아니라 함수에 인자를 전달할 때도 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">takes_ownership</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{s}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 여기서 s가 drop됨</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">takes_ownership</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// s의 소유권이 함수로 이동</span>\n    <span class=\"token comment\">// println!(\"{s}\"); // 오류! s는 이미 이동됨</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code>takes_ownership</code> 함수에 <code>s</code>를 전달하면 소유권이 함수 내부의 매개변수로 이동합니다.\n함수가 끝나면 그 매개변수가 스코프를 벗어나면서 메모리가 해제됩니다.\n따라서 함수 호출 후에는 원래 변수를 사용할 수 없습니다.</p>\n<p>함수에서 값을 반환하면 소유권을 다시 호출자에게 전달할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">gives_ownership</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s <span class=\"token comment\">// 소유권을 반환</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token function\">gives_ownership</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 반환된 값의 소유권을 받음</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{s}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 매번 소유권을 주고받는 것은 번거롭습니다.\n값을 잠시 빌려서 사용하고 싶을 때는 어떻게 해야 할까요?</p>\n<h2 id=\"참조와-빌림-references--borrowing\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0%EC%99%80-%EB%B9%8C%EB%A6%BC-references--borrowing\" aria-label=\"참조와 빌림 references  borrowing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조와 빌림 (References &#x26; Borrowing)</h2>\n<p>참조(Reference)를 사용하면 소유권을 이동하지 않고 값을 빌려서 사용할 수 있습니다.\n<code>&#x26;</code> 기호를 사용하여 참조를 생성합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">calculate_length</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">usize</span> <span class=\"token punctuation\">{</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// s는 참조이므로 drop되지 않음</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> len <span class=\"token operator\">=</span> <span class=\"token function\">calculate_length</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// s의 참조를 전달</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{s}의 길이는 {len}입니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// s 여전히 사용 가능</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-code-title\">결과</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hello의 길이는 <span class=\"token number\">5</span>입니다.</code></pre></div>\n<p><code>&#x26;s</code>는 <code>s</code>를 가리키는 참조를 생성합니다.\n<code>calculate_length</code> 함수는 <code>String</code>의 참조인 <code>&#x26;String</code>을 받습니다.\n참조는 소유권을 가지지 않기 때문에 함수가 끝나도 원본 값은 drop되지 않습니다.\n이렇게 참조를 통해 값을 사용하는 것을 빌림(borrowing)이라고 합니다.</p>\n<p>기본적으로 참조는 불변(immutable)입니다.\n참조를 통해 값을 읽을 수는 있지만 수정할 수는 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">try_modify</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// s.push_str(\" world\"); // 오류! 불변 참조로는 수정 불가</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"가변-참조-mutable-references\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B3%80-%EC%B0%B8%EC%A1%B0-mutable-references\" aria-label=\"가변 참조 mutable references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변 참조 (Mutable References)</h2>\n<p>값을 수정하려면 가변 참조(mutable reference)를 사용해야 합니다.\n<code>&#x26;mut</code> 키워드로 가변 참조를 생성합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">append_world</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">push_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\", world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">append_world</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{s}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-code-title\">결과</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hello, world<span class=\"token operator\">!</span></code></pre></div>\n<p>가변 참조를 사용하려면 원본 변수도 <code>mut</code>으로 선언되어 있어야 합니다.</p>\n<p>가변 참조에는 중요한 제약이 있습니다.\n특정 스코프에서 특정 데이터에 대한 가변 참조는 하나만 존재할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> r1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// let r2 = &amp;mut s; // 오류! 동시에 두 개의 가변 참조 불가</span>\n\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{r1}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한 불변 참조가 있는 동안에는 가변 참조를 만들 수 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> r1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 불변 참조 - OK</span>\n<span class=\"token keyword\">let</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 불변 참조 - OK</span>\n<span class=\"token comment\">// let r3 = &amp;mut s; // 오류! 불변 참조가 있는 동안 가변 참조 불가</span>\n\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{r1}, {r2}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 제약이 있는 이유는 데이터 경쟁(data race)를 컴파일 시점에 방지하기 위해서입니다.\n데이터 경쟁은 두 개 이상의 포인터가 동시에 같은 데이터에 접근하고, 그 중 하나 이상이 쓰기 작업을 할 때 발생합니다.\nRust는 이런 상황을 애초에 컴파일되지 않게 만들어서 런타임 버그를 예방합니다.</p>\n<h2 id=\"댕글링-참조-방지\" style=\"position:relative;\"><a href=\"#%EB%8C%95%EA%B8%80%EB%A7%81-%EC%B0%B8%EC%A1%B0-%EB%B0%A9%EC%A7%80\" aria-label=\"댕글링 참조 방지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>댕글링 참조 방지</h2>\n<p>댕글링 참조(dangling reference)는 이미 해제된 메모리를 가리키는 포인터입니다.\nC/C++에서는 이런 포인터를 사용하면 정의되지 않은 동작이 발생할 수 있습니다.\nRust는 컴파일러가 댕글링 참조를 허용하지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">// 이 코드는 컴파일되지 않음</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">dangle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">&amp;</span>s <span class=\"token comment\">// s의 참조를 반환하려고 함</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// s가 drop되어 참조가 무효화됨</span></code></pre></div>\n<p>컴파일러는 <code>s</code>가 함수가 끝나면서 drop되기 때문에 그 참조를 반환할 수 없다는 것을 알고 오류를 발생시킵니다.\n해결책은 참조 대신 소유권을 반환하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">no_dangle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s <span class=\"token comment\">// 소유권을 호출자에게 이동</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"슬라이스-slices\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%9D%BC%EC%9D%B4%EC%8A%A4-slices\" aria-label=\"슬라이스 slices permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬라이스 (Slices)</h2>\n<p>슬라이스는 컬렉션의 연속된 일부분을 참조하는 방법입니다.\n슬라이스도 참조의 일종이므로 소유권을 가지지 않습니다.</p>\n<p>문자열 슬라이스는 <code>&#x26;str</code> 타입을 가지며, <code>String</code>의 일부분을 참조할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> hello <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// \"hello\"</span>\n    <span class=\"token keyword\">let</span> world <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">..</span><span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"world\"</span>\n\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{hello} {world}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>범위 문법에서 시작 인덱스가 0이면 생략할 수 있고, 끝까지 가면 끝 인덱스도 생략할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> slice1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// \"he\"와 동일</span>\n<span class=\"token keyword\">let</span> slice2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// \"lo\"와 동일</span>\n<span class=\"token keyword\">let</span> slice3 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 전체 문자열</span></code></pre></div>\n<p>슬라이스를 사용하는 실용적인 예제를 살펴보겠습니다.\n문자열에서 첫 번째 단어를 찾아 반환하는 함수입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">first_word</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> bytes <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> bytes<span class=\"token punctuation\">.</span><span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">enumerate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> item <span class=\"token operator\">==</span> <span class=\"token char\">b' '</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> word <span class=\"token operator\">=</span> <span class=\"token function\">first_word</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"첫 번째 단어: {word}\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-code-title\">결과</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">첫 번째 단어: hello</code></pre></div>\n<p>문자열 리터럴도 슬라이스입니다.\n<code>let s = \"hello\";</code>에서 <code>s</code>의 타입은 <code>&#x26;str</code>로, 바이너리에 저장된 문자열을 가리키는 슬라이스입니다.\n그래서 문자열 리터럴은 불변인 것이죠.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>Rust의 소유권 시스템은 처음에는 낯설고 제약이 많게 느껴질 수 있습니다.\n하지만 이 규칙들 덕분에 메모리 안전성을 컴파일 시점에 보장받을 수 있습니다.</p>\n<p>핵심 규칙을 정리하면 다음과 같습니다.\n각 값은 하나의 소유자만 가지며, 소유자가 스코프를 벗어나면 값이 drop됩니다.\n참조를 통해 소유권 이동 없이 값을 빌릴 수 있습니다.\n불변 참조는 여러 개 가능하지만, 가변 참조는 동시에 하나만 존재할 수 있습니다.</p>\n<p>이 개념들이 익숙해지면 Rust 컴파일러의 오류 메시지가 두렵지 않게 될 것입니다.\n다음 단계로는 라이프타임(Lifetime)에 대해 학습하시면 참조의 유효 범위를 더 세밀하게 다룰 수 있습니다.</p>\n<p>Rust의 다른 기초 개념들은 <a href=\"/rust-struct/\">구조체</a>와 <a href=\"/rust-enum/\">열거형</a> 글에서 살펴보실 수 있습니다.</p>","timeToRead":6,"fields":{"slug":"/rust-ownership/","tags":["Rust","ownership","borrowing"]},"frontmatter":{"title":"Rust 기초: 소유권(Ownership)과 빌림(Borrowing)","date":"Dec 6, 2025"}},"next":{"fields":{"slug":"/git-head/"},"frontmatter":{"title":"Git에서 HEAD란 무엇인가?"}}}},
    "staticQueryHashes": ["2168229929","2362167539","3056348342"]}