{"componentChunkName":"component---src-templates-detail-template-jsx","path":"/http-status-codes/","result":{"pageContext":{"previous":null,"node":{"html":"<p>웹 개발자라면 200, 404, 500과 같은 HTTP 상태 코드에 대해 한 번쯤은 들어보셨을텐데요.\n경험을 통해서 이렇게 자주 보이는 코드에 대해서 막연히 감은 있으시지만, 실제로 내가 HTTP 상태 코드에 대해서 정확히 알고 있는지에 대해서 의문이 들 때가 있으실 것입니다.</p>\n<p>특히 서버 개발자라면 요즘에 웹이나 Rest API 개발을 간편하게 해주는 프레임워크가 워낙 잘 나와있다보니 어떤 상태 코드를 응답해야하는지에 대해서 오히려 소홀해지기 쉬워진 것 같아요.\n이번 글에서는 웹 개발에 있어서 HTTP 상태 코드가 얼마나 중요한지에 대해서 알아보고 HTTP 상태 코드를 올바르게 사용하는 방법에 대해서 살펴보겠습니다.</p>\n<h2 id=\"http-상태-코드-중요성\" style=\"position:relative;\"><a href=\"#http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%EC%A4%91%EC%9A%94%EC%84%B1\" aria-label=\"http 상태 코드 중요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 상태 코드 중요성</h2>\n<p>웹은 HTTP 프로토콜 통해 서버와 클라이언트 간에 원격 통신으로 돌아가죠?\n기본적으로 클라이언트에서 요청을 보내면 서버는 이를 받아서 처리한 후 응답을 보냅니다.\n그리고 이렇게 데이터를 주고 받는 과정이 클라이언트와 서버 간에 계속해서 반복해서 일어나죠.</p>\n<p>서버가 클라이언트 요청을 항상 성공적으로 처리하고 응답을 줄 수 있다면 너무 좋겠지만,\n실제 세상에는 이를 방해할 수 있는 변수가 너무나도 많죠?\n클라이언트가 실수로 잘못된 요청을 보낼 수도 있고 서버의 유지보수를 위해서 일시적으로 다운이 될 수도 있습니다.\n또한 여러 클라이언트가 동시에 보내는 요청 때문에 서버에는 여러가지 예상치 못한 상황이 문제가 발생할 수도 있습니다.</p>\n<p>이렇게 다양한 상황이 발생할 수 있는 웹에서 HTTP 상태 코드는 클라이언트와 서버 간의 통신에 있어서 핵심적인 역할을 담당하는데요.\n바로 서버가 클라이언트의 요청에 응답을 할 때 처리 결과에 대해서 미리 약속된 표준 코드를 통해서 효과적으로 피드백을 줄 수 있다는 것입니다.</p>\n<p>그래서 HTTP 상태 코드는 프로그래밍 언어를 불문하고 HTTP 기반으로 이뤄지는 웹 개발에 있어서 정말로 중요한 주제인데요.\n백엔드 개발자는 서버의 상황에 따라 정확한 HTTP 상태 코드를 응답함으로써 클라이언트에게 서버에 어떤 일이 발생했는지 알려줄 수 있고,\n프런트엔드 개발자는 수신된 HTTP 상태 코드를 보고 굳이 응답 바디(body)를 해석하지 않고도 요청 처리 결과를 빠르게 파악하고 이에 따라 적절한 후속 처리를 구현할 수 있습니다.\n게다가 이러한 HTTP 기반 상호작용은 REST API를 통해서 서버 간에서도 빈번하게 일어날 수 있기 때문에 상황에 따라 서버가 클라이언트가 될 수도 있고 클라이언트가 서버가 될 수도 있습니다.</p>\n<p>그리고 HTTP 상태 코드는 개발자가 클라이언트와 서버 간의 통신을 디버깅하고 모니터링하는데도 큰 도움이 됩니다.\n비용이나 성능 등의 이유로 웹 로그를 확인해보면 응답 헤더와 바디는 생략하고 HTTP 상태 코드만 남기는 경우가 많은데요.\n많은 모니터링 도구들이 HTTP 상태 코드를 기준으로 트래픽을 분류해서 알람도 보내고 통계도 만듭니다.</p>\n<p>무엇보다도 서버에서 올바른 HTTP 상태 코드를 응답하는 것이 중요한 가장 큰 이유는 이 것이 해당 <strong>웹 서비스의 사용성과 신뢰성</strong>에 직결된 문제이며 클라이언트의 경험에 큰 영향을 주기 때문입니다.</p>\n<p>서버에서 상황에 맞지 않는 HTTP 상태 코드가 응답하면 클라이언트는 서버에서 응답하는 HTTP 상태 코드를 신뢰하기 어려워지고 클라이언트의 안정성도 떨어지게 됩니다.\n뿐만 아니라 클라이언트에서는 방어적으로 예외 처리를 해야하기 때문에 코드가 불필요하게 복잡해지고 결국 클라이언트의 성능에도 부정적인 결과를 초래할 수 있습니다.</p>\n<h2 id=\"상태-코드의-구조와-범주\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%B2%94%EC%A3%BC\" aria-label=\"상태 코드의 구조와 범주 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상태 코드의 구조와 범주</h2>\n<p>HTTP 상태 코드는 3자리 숫자로 이루어져 있으며 크게 5개의 범주로 나눕니다.\n그래서 수 많은 상태 코드를 일일이 다 기억하기는 힘들지만 맨 앞 숫자만 보고도 대강 어떤 성격의 코드인지를 유추할 수 있는데요.</p>\n<ul>\n<li><code>1xx</code> 범주의 상태 코드는 단순 웹 개발자가 직접 사용할 일은 거의 없기 때문에 특별히 다루지는 않도록 하겠습니다.</li>\n<li><code>2xx</code> 범주의 상태 코드는 클라이언트의 요청이 올바르게 전달되었고 서버가 요청을 성공적으로 처리되었음을 의미합니다.</li>\n<li><code>3xx</code> 상태 코드는 클라이언트가 요청한 리소스가 다른 위치에 있거나 재요청이 필요함을 나타냅니다.</li>\n<li><code>4xx</code> 범주의 상태 코드는 처리가 실패하였는데 그 원인이 클라이언트 측에 있고 그래서 클라이언트에서 스스로 해결해야하는 경우를 의미합니다.</li>\n<li><code>5xx</code> 범주의 상태 코드는 처리가 실패하였는데 그 원인이 서버 측에서 있고 그래서 기본적으로 서버에서 조치가 필요한 상황을 나타냅니다.</li>\n</ul>\n<p>대부분의 HTTP 클라이언트는 따로 설정을 해주지 않으면 서버로 부터 처리 실패를 나타내는 <code>4xx</code>와 <code>5xx</code> 범주의 상태 코드가 응답되면 예외를 발생시킵니다.</p>\n<p>자, 그럼 지금부터 웹 개발을 하면서 자주 접하게 되는 HTTP 상태 코드를 하나씩 살펴보겠습니다.</p>\n<h2 id=\"200-ok\" style=\"position:relative;\"><a href=\"#200-ok\" aria-label=\"200 ok permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>200 OK</h2>\n<p><code>200</code> 상태 코드는 <code>OK</code>, 즉 클라이언트의 요청이 성공적으로 처리되었음을 의미하는데요.\n아마도 클라이언트에서 가장 좋아하는 상태 코드가 아닐까 싶습니다.</p>\n<p>서버가 클라리언트의 요청을 제대로 이해하고 문제없이 처리하였을 때 <code>200 OK</code>를 응답해야하며 응답 바디(response body)에 요청한 데이터가 담겨 옵니다.\n그래서 클라이언트에서는 응답 바디를 읽어야 하며(parse) 해당 프로그래밍 언어에서 데이터를 소비하기 쉬운 형태로 역직렬화(deserialization) 작업을 해줘야 합니다.</p>\n<p>이러한 특징 때문에 <code>200 OK</code>는 <code>GET</code> 방식의 요청에 응답할 때 적합합니다.\n하지만 개발의 편의를 핑계로 문제없이 요청이 처리되었다면 무조건 <code>200 OK</code>로 퉁쳐서 응답하는 서버도 가끔 볼 수 있는데요.\n이럴 경우 클라이언트에서 혼선이 발생할 수도 있고 섬세한 캐싱 작업이 어려워지기 때문에 <code>200 OK</code>를 납용하지 않도록 주의해야겠습니다.</p>\n<h2 id=\"201-created\" style=\"position:relative;\"><a href=\"#201-created\" aria-label=\"201 created permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>201 Created</h2>\n<p><code>201</code> 상태 코드는 <code>Created</code>, 즉 클라이언트의 요청으로 인해 서버에 새로운 리소스(resource)가 생성되었음을 의미합니다.</p>\n<p>웹 페이지든 REST API든 무언가를 생성하고 싶을 때는 보통 서버로 <code>POST</code> 방식의 요청을 보내죠?\n예를 들어서, 새로운 글을 작성하려면 <code>POST /posts</code> 요청을 보내고, 20번 포스팅에 댓글을 달려면 <code>POST /posts/20/comments</code> 요청을 보냅니다.</p>\n<p>서버에서는 클라이언트의 요청에 따라서 정상적으로 리소스가 생성되었을 때 <code>201 Created</code> 상태를 응답해야하며 이때 <code>Location</code> 응답 헤더에 생성된 리소스의 URL을 함께 보내는 것이 관례입니다.\n왜냐하면 서버에 리소스가 성공적으로 생성되면 클라이언트는 자연스럽게 해당 리소스로 이동하고 싶은 경우가 대부분이기 때문입니다.</p>\n<h2 id=\"204-no-content\" style=\"position:relative;\"><a href=\"#204-no-content\" aria-label=\"204 no content permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>204 No Content</h2>\n<p><code>204</code> 상태 코드는 <code>No Content</code>, 즉 서버가 응답할 데이터가 없음을 의미합니다.</p>\n<p>이 상태 코드는 리소스 삭제를 위한 <code>DELETE</code> 방식이 요청이나 리소스 수정을 위한 <code>PUT</code> 또는 <code>PATCH</code> 방식의 요청을 처리할 때 유용하게 쓰이는데요.\n왜냐하면 리소스를 삭제한 후에는 서버가 딱히 돌려보낼 데이터가 없으며, 리소스를 수정하는 경우에는 클라이언트가 이미 수정 내용을 알고 있기 때문입니다.</p>\n<p>따라서 서버는 <code>204 No Content</code>를 응답하여 클라이언트에게 명시적으로 요청이 정상적으로 처리되었지만 돌려줄 데이터는 없다고 알려주는 것입니다.\n응답 바디에 요청한 데이터를 담아서 전송할 때 사용되는 <code>200 OK</code>와 대조되는 부분이죠.\n서버로 부터 <code>204 No Content</code>이 수신되면 클라이언트에서는 해당 리소스를 캐시에서 삭제하는 등의 적절한 후속 조치를 취할 수 있습니다.</p>\n<h2 id=\"301-moved-permanently\" style=\"position:relative;\"><a href=\"#301-moved-permanently\" aria-label=\"301 moved permanently permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>301 Moved Permanently</h2>\n<p><code>301</code> 상태 코드는 <code>Moved Permanently</code>, 즉 클라이언트가 요청한 리소스가 <strong>영구적으로</strong> 새로운 위치로 이동되었음을 의미합니다.\n이 경우, 클리이언트는 서버에서 돌려준 <code>Location</code> 응답 헤더에 명시된 새로운 URL로 해당 리소스를 재요청해야합니다.</p>\n<p><code>301 Moved Permanently</code>는 특히 SEO(검색 엔진 최적화) 측면에서 중요한데요.\n검색 엔진은 크롤링(crawling)할 때 이 상태 코드를 통해서 웹 페이지의 URL이 바뀌었다는 것을 감지하여 인덱싱(indexing)에 반영할 수 있기 때문입니다.\n그래서 웹사이트의 도메인 네임을 변경하였거나 대대적인 개편을 하여 사이트이 바뀌었을 때 때 매우 유용하게 사용됩니다.</p>\n<h2 id=\"302-found\" style=\"position:relative;\"><a href=\"#302-found\" aria-label=\"302 found permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>302 Found</h2>\n<p><code>302</code> 상태 코드는 <code>Found</code> 또는 <code>Moved Temporarily</code>, 즉 클라이언트가 요청한 리소스가 <strong>일시적으로</strong> 다른 위치에 있음을 의미합니다.</p>\n<p>주로 인증을 하지 않은 사용자를 일시적으로 로그인 페이지로 보내기 위해서 많이 사용되는데요.\n로그인이 끝나면 다시 원래 URL에 접근할 수 있다는 점에서 <code>301 Moved Permanently</code> 상태 코드와 분명한 차이가 있습니다.</p>\n<p><code>301</code> 상태 코드와 <code>302</code> 상태 코드가 각각 언제 사용해야하는지 헛갈리시나요?\n클라이언트가 다음에 같은 리소스를 요청할 때 새로운 URL을 사용했으면 하신다면 <code>301</code> 상태 코드를 사용해야합니다.\n반면에 클라이언트가 다음에 같은 리소스를 요청할 때도 같은 URL을 사용하길 원하신다면 <code>302</code> 상태 코드를 사용하시면 됩니다.</p>\n<h2 id=\"304-not-modified\" style=\"position:relative;\"><a href=\"#304-not-modified\" aria-label=\"304 not modified permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>304 Not Modified</h2>\n<p><code>304</code> 상태 코드는 <code>Not Modified</code>, 즉 클라이언트가 이전에 요청한 리소스가 서버에서 수정되지 않았음을 의미합니다.</p>\n<p>클라이언트 측 캐싱에서 <code>304 Not Modified</code>은 핵심적인 역할을 담당하는데요.\n클라이언트가 이전에 이미 요청한 리소스를 다시 요청하면, 서버는 실제 데이터를 다시 전송하지 않고 <code>304 Not Modified</code> 상태 코드를 반환할 수 있습니다.</p>\n<p>이를 통해 서버는 불필요한 데이터 전송을 피하고 DB 부하를 줄일 수 있으며 더 많은 동시 요청을 처리할 수 있게 되고요.\n클리이언트는 캐시된 리소스를 재사용할 수 있기 때문에 성능을 향상을 기대할 수 있습니다.</p>\n<p>이 부분에 대해서는 <code>ETag</code>에 대해서도 알아야하고 매커니즘이 좀 복잡하기 때문에 추후 기회가 되면 별도 포스팅에서 자세히 다루도록 하겠습니다.</p>\n<h2 id=\"400-bad-request\" style=\"position:relative;\"><a href=\"#400-bad-request\" aria-label=\"400 bad request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>400 Bad Request</h2>\n<p><code>400</code> 상태 코드는 <code>Bad Request</code>, 즉 클라이언트가 잘못된 요청을 보냈다는 것을 의미합니다.</p>\n<p>클라이언트는 경로, 요청 헤더, 쿼리 스트링, 요청 바디 등 다양한 방법을 통해서 서버로 입력 데이터를 실어서 요청할 수 있는데요.\n서버에서는 잘못된 데이터가 유입되지 않도록 보통 입력값 검증을 수행하며 이 검증이 실패할 경우 <code>400 Bad Request</code>를 응답해야합니다.\n그리고 추가적으로 응답 바디에 구체적으로 어떤 입력 파라미터가 형식에 맞지 않는지 클리이언트에게 정확한 피드백을 주는 것이 좋습니다.</p>\n<p>예를 들어, 데어터 검색을 위해서 클라이언트가 <code>?query={검색어}</code> 형태로 쿼리 스트링을 보내야하는데 <code>?q={검색어}</code> 형태로 보낼 경우 서버는 해당 요청을 제대로 처리할 수 없을 것입니다.\n이 때 서버는 <code>400 Bad Request</code>를 응답하고 응답 바디를 통해서 <code>query</code> 파라미터가 누락되어 있다고 클라이언트에게 알려줄 수 있습니다.</p>\n<h2 id=\"401-unauthorized\" style=\"position:relative;\"><a href=\"#401-unauthorized\" aria-label=\"401 unauthorized permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>401 Unauthorized</h2>\n<p><code>401</code> 상태 코드는 <code>Unauthorized</code>, 즉 클라이언트가 미인증 상태에서 요청을 했다는 것을 의미입니다.</p>\n<p>클라이언트가 인증 토큰을 <code>Authorization</code> 요청 헤더에 설정해주지 않고 REST API에 요청을 보냈을 때 서버는 <code>401 Unauthorized</code>을 응답해야합니다.</p>\n<h2 id=\"403-forbidden\" style=\"position:relative;\"><a href=\"#403-forbidden\" aria-label=\"403 forbidden permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>403 Forbidden</h2>\n<p><code>403</code> 상태 코드는 <code>Forbidden</code>, 즉 클라이언트가 보호된 리소스를 요청할 권한이 없다는 것을 의미합니다.</p>\n<p>아예 인증이 되지 않는 요청에 대해서 사용되는 <code>401</code> 상태 코드와의 차이점이라고 한다면 <code>403</code> 상태 코드 인증은 성공하였지만 인가에 실패하였을 때 사용됩니다.\n예를 들어서, 일반 사용자의 권한으로 인증을 한 클라이언트가 관리자 권한으로만 접근할 수 있는 리소스를 요청하면 서버에서는 <code>403 Forbidden</code>을 응답해야 합니다.</p>\n<h2 id=\"404-not-found\" style=\"position:relative;\"><a href=\"#404-not-found\" aria-label=\"404 not found permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>404 Not Found</h2>\n<p><code>404</code> 상태 코드는 <code>Not Found</code>, 즉 클라이언트가 요청한 리소스를 찾을 수 없음을 의미하는데요.\n웹에서 404 페이지를 워낙 흔하기 볼 수 있기 때문에 일반인들에게도 친숙한 상태 코드이기도 합니다.</p>\n<p><code>404 Not Found</code>는 클라이언트가 서버에 존재하지 않거나 삭제된 리소스를 요청할 때 사용되는데요.\n예를 들어서, 클라이언트가 <code>GET /posts/101</code> 요청을 보냈을 때 서버에 ID가 101인 게시물이 없다면 <code>404 Not Found</code>를 응답해야 합니다.</p>\n<p><code>404</code> 상태 코드 관련해서 흔히 발생하는 실수가 여러 리소스를 찾을 수 없는 상황에서 <code>404 Not Found</code>를 응답하는 것인데요.\n예를 들어서, 클라이언트가 <code>GET /posts?search=xyz</code> 요청을 보냈는데 <code>xyz</code>가 포함된 게시물이 없는 상황에서 <code>404</code> 상태 코드를 사용하는 것이지요.</p>\n<p>이런 경우에는 <code>200 OK</code>와 빈 배열을 반환하는 편이 클라이언트에게 더 나은 경험을 줄 수 있습니다.\n왜냐하면 <code>200</code> 상태 코드를 응답하면 단순히 배열의 크기만 확인하면 되는데 <code>404</code> 상태 코드를 응답하면 별도로 예외 처리를 해줘야하기 때문입니다.</p>\n<h2 id=\"429-too-many-requests\" style=\"position:relative;\"><a href=\"#429-too-many-requests\" aria-label=\"429 too many requests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>429 Too Many Requests</h2>\n<p><code>429</code> 상태 코드는 <code>Too Many Requests</code>, 즉 클라이언트가 일정 시간 내에 너무 많은 요청을 보냈음을 의미합니다.</p>\n<p>보통 REST API 서버에서는 과부하를 방지하고 서비스의 품질을 보장하기 위해서 Rate Limit, 즉 클라이언트 별로 일정 시간 동안 API를 호출할 수 있는 횟수를 제한하는데요.\n만약에 클라이언트가 주어진 횟수를 초과하는 요청을 보내면 서버에서는 <code>429 Too Many Requests</code>를 응답해야 합니다.</p>\n<p>또한 유료 사용자와 무료 사용자와의 API 사용량의 차등을 두기 위해서도 이 상태 코드를 활용할 수도 있습니다.</p>\n<h2 id=\"500-internal-server-error\" style=\"position:relative;\"><a href=\"#500-internal-server-error\" aria-label=\"500 internal server error permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>500 Internal Server Error</h2>\n<p><code>500</code> 상태 코드는 <code>Internal Server Error</code>, 즉 서버 측에서 일어난 내부적인 오류로 인해 요청을 처리할 수 없는 상태를 의미합니다.</p>\n<p><code>500 Internal Server Error</code>는 서버의 코드나 설정에 문제가 있어서 정상적으로 요청을 처리할 수 없는 상태를 나타내는 대표적인 <code>5xx</code> 범주에 속하는 상태 코드인데요.\n클라이언트 입장에서 이 상태 코드를 받게 되면 서버에서 문제가 해결될 때 까지 기다리는 방법이 없기 때문에 답답한 상태 코드이기도 합니다.</p>\n<p>서버 개발자가 의도적으로 <code>500</code> 상태 코드를 응답하도록 코드를 짤 수도 있지만,\n그 보다는 프레임워크 수준에서 의도치 않게 발생한 예외나 에러를 잡아서 자동으로 <code>500</code> 상태 코드를 응답해주는 경우가 더 많습니다.\n그래서 웹 개발을 할 때 클라이언트 서버 가리지 않고 자주 마주치게 되는 상태 코드이기도 합니다.</p>\n<h2 id=\"503-service-unavailable\" style=\"position:relative;\"><a href=\"#503-service-unavailable\" aria-label=\"503 service unavailable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>503 Service Unavailable</h2>\n<p><code>503</code> 상태 코드는 <code>Service Unavailable</code>, 즉 서버가 일시적으로 서비스를 할 수 없는 상태를 의미합니다.</p>\n<p>이 상태 코드를 서버 개발자가 직접 사용할 일을 드믈고 주로 서버가 과부하 상태에 빠지거나 유지보수를 위해 다운된 상태일 때 미들웨어나 프록시 서버에서 응답되는 경우가 많습니다.\n대표적인 예로 DDoS 공격을 받은 서비스가 <code>503 Service Unavailable</code>을 응답하는 경우를 들 수 있겠습니다.</p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>지금까지 웹 개발자로서 HTTP 상태 코드의 중요성을 상기하고 반드시 알고 있어야 하는 HTTP 상태 코드를 정리해보았습니다.</p>\n<p>사실 HTTP 스펙에는 이 것보다 훨씬 많은 상태 코드가 있지만 대부분 잘 안 쓰이지 않거나 스펙 상으로만 존재하는 경우가 많은데요.\n혹시 본 포스팅에서 다루지 않은 HTTP 상태 코드는 마주치신다면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\">관련 MDN 레퍼런스 문서</a>를 찾아서 학습하시면 좋을 것 같습니다.</p>\n<p>이 글이 HTTP 상태 코드를 올바르게 사용하는데 있어서 많은 개발자분들에게 좋은 안내서가 되길 바라며 이만 줄이겠습니다.</p>","timeToRead":9,"fields":{"slug":"/http-status-codes/","tags":["HTTP","response","status"]},"frontmatter":{"title":"웹 개발자를 위한 HTTP 상태 코드 안내서","date":"Jul 26, 2023"}},"next":{"fields":{"slug":"/meta-frameworks/"},"frontmatter":{"title":"범람하는 자바스크립트의 메타 프레임워크"}}}},"staticQueryHashes":["2168229929","2362167539","3056348342"]}