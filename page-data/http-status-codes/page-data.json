{
    "componentChunkName": "component---src-templates-detail-template-jsx",
    "path": "/http-status-codes/",
    "result": {"pageContext":{"previous":{"fields":{"slug":"/css-screen-height/"},"frontmatter":{"title":"CSS로 화면 높이의 HTML 요소 만들기"}},"node":{"html":"<p>웹 개발자라면 200, 404, 500과 같은 HTTP 상태 코드에 대해 한 번쯤은 들어보셨을텐데요.\n경험을 통해서 이렇게 자주 보이는 코드에 대해서 막연히 감은 있으시지만, 실제로 내가 HTTP 상태 코드에 대해서 잘 알고 있는지에 대해서 스스로 의문이 들 때가 있으실 것입니다.</p>\n<p>특히 백엔드 개발자라면 요즘에 웹이나 Rest API 개발을 간편하게 해주는 프레임워크가 워낙 잘 나와있다보니, 어떤 상태 코드를 응답하고 있는지에 대해서 오히려 소홀해 질 수 있는 것 같아요.\n이번 글에서는 웹 개발에 있어서 HTTP 상태 코드가 얼마나 중요한지에 대해서 알아보고, HTTP 상태 코드를 올바르게 사용하는 방법에 대해서 살펴보겠습니다.</p>\n<h2 id=\"http-상태-코드-중요성\" style=\"position:relative;\"><a href=\"#http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%EC%A4%91%EC%9A%94%EC%84%B1\" aria-label=\"http 상태 코드 중요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 상태 코드 중요성</h2>\n<p>웹은 기본적으로 HTTP 프로토콜 통해 서버와 클라이언트 간에 원격 통신으로 돌아가죠?\n쉽게 말해서 클라이언트에서 요청을 보내면 서버는 이를 받아서 처리한 후 응답을 보냅니다.\n그리고 이렇게 데이터를 주고 받는 과정이 클라이언트와 서버 사이에서 계속해서 반복적으로 일어나죠.</p>\n<p>서버가 클라이언트 요청을 항상 성공적으로 처리하고 응답을 줄 수 있다면 이상적이겠지만 실제 세상에는 이를 방해할 수 있는 변수가 너무나도 많죠?\n클라이언트가 실수로 잘못된 요청을 보낼 수도 있으며, 서버 측의 유지보수 작업으로 인해 서비스가 일시적으로 다운될 수도 있습니다.\n또한 클라이언트가 동시에 보내는 요청이 폭증하여 서버에서는 여러가지 예상치 못한 상황이 장애 상황이 발생할 수도 있죠.</p>\n<p>이렇게 다양한 상황이 발생할 수 있는 웹에서 HTTP 상태 코드는 클라이언트와 서버가 효과적으로 상호작용을 하기 위해서 핵심적인 역할을 담당하는데요.\n바로 HTTP 상태 코드를 통해 서버는 미리 약속된 표준 코드를 클라이언트에게 응답하여, 요청 처리 결과에 대한 명확한 피드백을 줄 수 있다는 것입니다.</p>\n<p>그래서 HTTP 상태 코드는 프로그래밍 언어를 불문하고 HTTP 기반으로 이뤄지는 웹 개발에 있어서 정말로 중요한 주제인데요.\n백엔드 개발자는 서버의 상황에 따라 정확한 HTTP 상태 코드를 응답함으로써 클라이언트에게 서버에 어떤 일이 발생했는지 알려줄 수 있고,\n프론트엔드 개발자는 굳이 응답 바디(body)를 처리하여 읽지 않고도 수신된 HTTP 상태 코드만을 보고 좀 더 효율적으로 적절한 후속 처리를 할 수 있습니다.\n게다가, 마이크로서비스 아키텍처(microservice architecture)에서는 HTTP 기반의 이러한 상호작용이 REST API를 통해 서버 사이에서도 빈번하게 발생할 수 있습니다.</p>\n<p>뿐만 아니라, HTTP 상태 코드는 개발자가 클라이언트와 서버 간의 통신을 디버깅(debugging)하고 모니터링(monitoring)하는데도 큰 도움이 됩니다.\n비용이나 성능 등의 이유로 웹 로그를 확인해보면 응답 헤더(header)와 바디(body)는 생략하고 HTTP 상태 코드만 남기는 경우가 많은데요.\n많은 모니터링 도구들이 HTTP 상태 코드를 기준으로 트래픽을 분류해서 알람도 보내고 통계도 만듭니다.</p>\n<p>무엇보다 서버에서 올바른 HTTP 상태 코드를 응답하는 것이 중요한 가장 큰 이유는 이 것이 해당 <strong>웹 서비스의 사용성과 신뢰성</strong>에 직결된 문제이며 클라이언트의 경험에 큰 영향을 주기 때문입니다.\n서버에서 처리 결과에 부합하지 않는 HTTP 상태 코드가 응답하면 클라이언트는 해당 API를 신뢰하기 어려워지고 클라이언트의 안정성도 떨어지게 됩니다.\n또한, 클라이언트에서는 방어적으로 예외 처리를 해야하기 때문에 코드가 불필요하게 복잡해지고 결국 클라이언트의 성능에도 부정적인 결과를 초래할 수 있습니다.</p>\n<h2 id=\"상태-코드의-구조와-범주\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%B2%94%EC%A3%BC\" aria-label=\"상태 코드의 구조와 범주 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상태 코드의 구조와 범주</h2>\n<p>3자리 숫자로 이루어진 HTTP 상태 코드는 크게 5개의 범주로 나누어지는데요.\n그래서 수 많은 상태 코드를 일일이 다 기억하기는 힘들지만, 맨 앞 숫자만 보고도 대강 어떤 성격의 코드인지를 유추할 수는 있죠.</p>\n<ul>\n<li><code>1xx</code> 범주의 상태 코드는 웹 개발자가 직접 사용할 일은 거의 없기 때문에 특별히 다루지는 않도록 하겠습니다.</li>\n<li><code>2xx</code> 범주의 상태 코드는 클라이언트의 요청이 올바르게 전달되었고 서버가 요청을 성공적으로 처리하였음을 나타냅니다.</li>\n<li><code>3xx</code> 상태 코드는 클라이언트가 요청한 리소스가 다른 위치에 있거나 재요청이 필요함을 나타냅니다.</li>\n<li><code>4xx</code> 범주의 상태 코드는 처리가 실패하였는데 그 원인이 클라이언트 측에 있고 그래서 클라이언트에서 스스로 해결해야하는 상황을 나타냅니다.</li>\n<li><code>5xx</code> 범주의 상태 코드는 처리가 실패하였는데 그 원인이 서버 측에서 있고 그래서 서버에서 조치를 취해줘야하는 상황을 나타냅니다.</li>\n</ul>\n<p>대부분의 HTTP 클라이언트 라이브러리나 프레임워크는 따로 설정을 해주지 않으면 서버로 부터 처리 실패를 나타내는 <code>4xx</code>와 <code>5xx</code> 범주의 상태 코드가 응답되면 예외를 발생시킵니다.\n따라서 서버에서 불필요하게 이 범주의 상태 코드를 응답하지 않도록 각별히 주의해야합니다.</p>\n<p>자, 그럼 지금부터 웹 개발을 하면서 자주 접하게 되는 HTTP 상태 코드를 하나씩 살펴볼까요?</p>\n<h2 id=\"200-ok\" style=\"position:relative;\"><a href=\"#200-ok\" aria-label=\"200 ok permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>200 OK</h2>\n<p><code>200</code> 상태 코드는 <code>OK</code>, 즉 클라이언트의 요청이 성공적으로 처리되었음을 나타내는데요.\n아마도 클라이언트 개발자들이 가장 좋아하는 상태 코드가 아닐까 싶습니다. 😇</p>\n<p>서버에서는 클라이언트의 요청을 제대로 이해하고 문제없이 처리하였을 때 <code>200 OK</code>를 응답해야하며 응답 바디(response body)에 요청한 데이터를 담아줘야 합니다.\n클라이언트에서는 응답 바디를 MIME type에 따라 적절히 처리 후에 읽어야 하며(parse), 해당 프로그래밍 언어에서 데이터를 다루기 쉬운 형태로 역직렬화(deserialization) 작업을 해줘야 합니다.</p>\n<p>HTTP 통신에서 일반적으로 <code>GET</code> 방식으로 데이터를 요청하기 때문에 <code>GET</code> 방식의 요청에 대한 응답에서 <code>200 OK</code>를 많이 보게되는데요.\n하지만 백엔드 개발자의 게으름이나 개발 편의를 핑계로 문제없이 요청이 처리되었다면 무조건 <code>200 OK</code>로 퉁쳐서 응답하는 서버도 종종 볼 수 있는데요.\n이럴 경우 클라이언트에서 혼선이 발생할 수 있고 섬세한 캐싱(caching) 처리도 어려워지기 때문에 <code>200 OK</code>를 납용하지 않도록 주의해야겠습니다.</p>\n<h2 id=\"201-created\" style=\"position:relative;\"><a href=\"#201-created\" aria-label=\"201 created permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>201 Created</h2>\n<p><code>201</code> 상태 코드는 <code>Created</code>, 즉 클라이언트의 요청으로 인해 서버에 새로운 리소스(resource)가 생성되었음을 의미합니다.</p>\n<p>웹 페이지든 REST API든 무언가를 생성하고 싶을 때는 보통 서버로 <code>POST</code> 방식의 요청을 보내죠?\n예를 들어서, 새로운 글을 작성하려면 <code>POST /posts</code>를 요청하고, 20번 포스팅에 댓글을 달려면 <code>POST /posts/20/comments</code>를 요청하게 됩니다.</p>\n<p>서버에서는 클라이언트의 요청에 따라 정상적으로 리소스가 생성되었을 때 <code>201 Created</code> 상태로 응답해야 하며, 이때 생성된 리소스의 URL은 <code>Location</code> 응답 헤더에 실어 보내는 것이 관례입니다.\n왜냐하면 서버에 리소스가 성공적으로 생성되면 클라이언트에서는 다음 수순으로 바로 해당 리소스로 이동해야하는 경우가 대부분이기 때문입니다.</p>\n<h2 id=\"204-no-content\" style=\"position:relative;\"><a href=\"#204-no-content\" aria-label=\"204 no content permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>204 No Content</h2>\n<p><code>204</code> 상태 코드는 <code>No Content</code>, 즉 서버가 응답할 데이터가 없음을 나타냅니다.</p>\n<p>이 상태 코드는 리소스 삭제를 위한 <code>DELETE</code> 방식의 요청이나 리소스 수정을 위한 <code>PUT</code> 또는 <code>PATCH</code> 방식의 요청을 처리할 때 유용하게 쓰이는데요.\n왜냐하면 리소스를 삭제한 후에는 서버가 딱히 돌려보낼 데이터가 없으며, 리소스를 수정하는 경우에도 클라이언트가 이미 수정 사항을 알고 있기 때문입니다.</p>\n<p>따라서 서버에서는 <code>204 No Content</code>를 응답하여 클라이언트에게 명시적으로 요청이 정상적으로 처리되었지만 돌려줄 데이터는 없다고 알려주는 것입니다.\n응답 바디에 요청한 데이터를 담아서 수신할 때 사용되는 <code>200 OK</code>와 대조되는 부분이죠.\n서버로 부터 <code>204 No Content</code>이 돌아오면 클라이언트에서는 해당 리소스를 캐시에서 삭제하는 등의 적절한 후속 조치를 취할 수 있습니다.</p>\n<h2 id=\"301-moved-permanently\" style=\"position:relative;\"><a href=\"#301-moved-permanently\" aria-label=\"301 moved permanently permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>301 Moved Permanently</h2>\n<p><code>301</code> 상태 코드는 <code>Moved Permanently</code>, 즉 클라이언트가 요청한 리소스가 <strong>영구적으로</strong> 새로운 위치로 이동되었음을 의미하는데요.\n이 경우, 클라이언트는 서버에서 반환된 <code>Location</code> 응답 헤더에 명시된 새로운 URL로 해당 리소스를 재요청해야 합니다.</p>\n<p><code>301 Moved Permanently</code>는 특히 SEO(검색 엔진 최적화) 측면에서 중요한데요.\n검색 엔진은 크롤링(crawling)할 때 이 상태 코드를 통해서 웹 페이지의 URL이 바뀌었다는 것을 감지하여 인덱싱(indexing)에 반영할 수 있기 때문입니다.\n그래서 웹사이트의 도메인 네임을 변경하였거나 대대적인 개편을 하여 사이트맵(sitemap)이 바뀌었을 때 매우 유용하게 사용됩니다.\n또한, 기존 URL이 폐기(deprecated)된 상태에서 클라이언트의 트래픽(traffic)을 새로운 URL로 점진적으로 유도해야할 때도 활용할 수 있습니다.</p>\n<h2 id=\"302-found\" style=\"position:relative;\"><a href=\"#302-found\" aria-label=\"302 found permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>302 Found</h2>\n<p><code>302</code> 상태 코드는 <code>Found</code> 또는 <code>Moved Temporarily</code>, 즉 클라이언트가 요청한 리소스가 <strong>일시적으로</strong> 다른 위치에 있음을 나타냅니다.</p>\n<p>이 상태 코드는 인증되지 않은 사용자를 일시적으로 로그인 페이지로 이동시키기 위해서 많이 사용되는데요.\n로그인이 끝나면 다시 원래 요청했던 URL에 접근할 수 있다는 점에서 <code>301 Moved Permanently</code> 상태 코드와 분명한 차이가 있습니다.</p>\n<p><code>301</code> 상태 코드와 <code>302</code> 상태 코드가 각각 언제 사용해야 하는지 헷갈릴 수 있는데요.\n클라이언트가 다음에 같은 리소스를 요청할 때 새로운 URL을 사용하길 원하신다면 <code>301</code> 상태 코드를 사용해야합니다.\n반면에 클라이언트가 다음에 같은 리소스를 요청할 때도 같은 URL을 사용하길 원하신다면 <code>302</code> 상태 코드를 사용하시면 됩니다.</p>\n<h2 id=\"304-not-modified\" style=\"position:relative;\"><a href=\"#304-not-modified\" aria-label=\"304 not modified permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>304 Not Modified</h2>\n<p><code>304</code> 상태 코드는 <code>Not Modified</code>, 즉 클라이언트가 이전에 요청한 리소스가 서버에서 아직까지 수정된 적이 없음을 의미합니다.</p>\n<p>이 상태 코드는 클라이언트 측 캐싱(caching)을 지원하는데 핵심적인 역할을 담당하는데요.\n클라이언트가 이전에 이미 요청한 리소스를 다시 요청하면, 서버에서는 실제 데이터를 다시 전송하지 않고 <code>304 Not Modified</code> 상태 코드를 반환할 수 있습니다.</p>\n<p>이를 통해 서버는 불필요한 데이터 전송을 피하여 네트워크 대역폭(bandwidth)을 아낄 수 있으며, DB 부하도 줄일 수 있고, 결국적으로 더 많은 동시 요청을 처리할 수 있게 되고요.\n클라이언트는 캐시된 리소스를 재사용할 수 있기 때문에 성능을 향상시켜 사용자에게 더 나은 경험을 제공할 수 있습니다.</p>\n<p>이러한 캐싱 메커니즘을 제대로 이해하려면 <code>ETag</code>에 대해서도 알아야 하며, 다른 여러 부분을 이해해야 합니다.\n따라서 추후에 별도의 포스팅에서 자세히 다루도록 하겠습니다.</p>\n<h2 id=\"400-bad-request\" style=\"position:relative;\"><a href=\"#400-bad-request\" aria-label=\"400 bad request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>400 Bad Request</h2>\n<p><code>400</code> 상태 코드는 <code>Bad Request</code>, 즉 클라이언트가 잘못된 요청을 보냈다는 것을 나타냅니다.</p>\n<p>클라이언트는 경로, 요청 헤더, 쿼리 스트링, 요청 바디 등 다양한 방법을 통해서 서버로 입력 데이터를 송신할 수 있는데요.\n서버에서는 잘못된 데이터가 유입되지 않도록 보통 입력값 검증을 수행하며 이 검증이 실패할 경우 <code>400 Bad Request</code>를 응답해야합니다.\n그리고 추가적으로 응답 바디에 구체적으로 어떤 입력 파라미터가 형식에 맞지 않는지 클리이언트에게 정확한 피드백을 주는 것이 좋습니다.</p>\n<p>예를 들어, 데어터 검색을 위해서 클라이언트가 <code>?query={검색어}</code> 형태로 쿼리 스트링을 보내야하는데 <code>?q={검색어}</code> 형태로 보낼 경우 서버는 해당 요청을 제대로 처리할 수 없을 것입니다.\n이 때 서버는 <code>400 Bad Request</code>를 응답하고 응답 바디를 통해서 <code>query</code> 파라미터가 누락되어 있고 불필요하게 <code>q</code> 파라미터를 보냈다고 클라이언트에게 알려줄 수 있습니다.</p>\n<h2 id=\"401-unauthorized\" style=\"position:relative;\"><a href=\"#401-unauthorized\" aria-label=\"401 unauthorized permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>401 Unauthorized</h2>\n<p><code>401</code> 상태 코드는 <code>Unauthorized</code>, 즉 클라이언트가 미인증 상태에서 요청을 했다는 것을 의미합니다.</p>\n<p>이 상태 코드는 보안 측면에서 매우 핵심적인 역할을 담당하는데요.\n서버에서 요구하는 인증 절차를 따르지 않고 들어온 요청에 대해서는 서버에서는 <code>401 Unauthorized</code>을 응답해야합니다.</p>\n<p>예를 들어, 서버에서 Bearer 토큰 방식의 인증을 하고 있는데 클라이언트가 <code>Authorization</code> 요청 헤더에 유효하지 않거나 만료된 토큰을 설정하였다면, 서버에서는 <code>401 Unauthorized</code>을 응답하여 처리를 거부할 수 있습니다.</p>\n<h2 id=\"403-forbidden\" style=\"position:relative;\"><a href=\"#403-forbidden\" aria-label=\"403 forbidden permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>403 Forbidden</h2>\n<p><code>403</code> 상태 코드는 <code>Forbidden</code>, 즉 클라이언트가 보호된 리소스를 요청할 권한이 없다는 것을 나타내는데요.\n단순히 사용자 인증에서 그치는 것이 아니라 리소스 별로 사용자의 역할에 따라 정교한 접근 통제를 해야하는 서버에서 많이 사용됩니다.</p>\n<p><code>401</code> 상태 코드는 아예 인증이 되지 않는 요청을 거부하기 위해서 사용되는 반면에, <code>403</code> 상태 코드는 인증(authentication)에는 성공하였더라도 특정 리소스를 접근할 권한이 없을 때, 즉 인가(authorization)에 실패하였을 때 사용됩니다.\n예를 들어서, 일반 사용자 역할로 인증을 한 클라이언트가 관리자 권한으로만 접근할 수 있는 리소스를 요청하면 서버에서는 <code>403 Forbidden</code>을 응답해야 합니다.</p>\n<h2 id=\"404-not-found\" style=\"position:relative;\"><a href=\"#404-not-found\" aria-label=\"404 not found permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>404 Not Found</h2>\n<p><code>404</code> 상태 코드는 <code>Not Found</code>, 즉 클라이언트가 요청한 리소스를 찾을 수 없음을 의미하는데요.\n웹에서 404 페이지를 워낙 흔하기 볼 수 있기 때문에 일반인들에게도 상당히 친숙한 상태 코드입니다.</p>\n<p>이 상태 코드는 클라이언트가 서버 측에 존재하지 않거나 삭제된 리소스를 요청할 때 사용되는데요.\n예를 들어서, 클라이언트가 <code>GET /posts/101</code> 요청을 했는데 서버에 ID가 101인 게시물이 없다면 <code>404 Not Found</code>를 응답해야 합니다.</p>\n<p>단, 클라이언트가 여러 리소스를 요청한 경우에는 <code>404 Not Found</code> 대신에 <code>200 OK</code>와 빈 배열을 반환하는 편이 좋은데요.\n왜냐하면 <code>200</code> 상태 코드를 응답하면 클라이언트에서 단순히 배열의 크기만 확인하면 되는데 <code>404</code> 상태 코드를 응답하면 별도로 예외 처리까지 해줘야하기 때문입니다.</p>\n<p>흔한 예로, 클라이언트가 <code>GET /posts?search=xyz</code> 요청을 보냈는데 서버에 <code>xyz</code>가 포함된 게시물이 없는 상황을 생각할 수 있겠습니다.\n클라이언트 입장에서 서버로 부터 <code>200</code> 상태 코드가 응답될 수도 있고 <code>404</code> 상태 코드가 응답될 수도 있다면 처리가 상당히 번거로워질 수 있습니다.\nUI 측면에서는 응답된 데이터가 0건이든 100건이든 크게 달라지는 부분이 많지 않기 때문이죠.</p>\n<h2 id=\"429-too-many-requests\" style=\"position:relative;\"><a href=\"#429-too-many-requests\" aria-label=\"429 too many requests permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>429 Too Many Requests</h2>\n<p><code>429</code> 상태 코드는 <code>Too Many Requests</code>, 즉 클라이언트가 일정 시간 내에 너무 많은 요청을 보냈음을 의미합니다.</p>\n<p>보통 REST API 서버에서는 과부하를 방지하고 서비스의 안정성을 보장하기 위해서 Rate Limit, 즉 클라이언트 별로 일정 시간 동안 요청할 수 있는 횟수에 제한을 두는데요.\n만약에 클라이언트가 주어진 최대 요청 회수를 초과하는 요청을 보내면, 서버에서는 <code>429 Too Many Requests</code>를 응답해야 합니다.\n또한 유료 사용자와 무료 사용자와의 API 사용량의 차등을 두기 위해서도 이 상태 코드를 활용할 수 있습니다.</p>\n<p>서버에서 Rate Limit을 구현할 때는 프레임워크에서 제공하는 기능을 쓰거나 별도의 라이브러리를 사용하는 경우가 많습니다.\n따라서 실제로 백엔드 개발자가 직접 이 상태 코드를 쓸 일은 그리 많지는 않을텐데요.\n하지만 프런트엔드 개발자에게는 알아두면 유용한 상태 코드입니다.</p>\n<h2 id=\"500-internal-server-error\" style=\"position:relative;\"><a href=\"#500-internal-server-error\" aria-label=\"500 internal server error permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>500 Internal Server Error</h2>\n<p><code>500</code> 상태 코드는 <code>Internal Server Error</code>, 즉 서버에서 발생한 내부적인 오류로 인해 요청을 처리할 수 없음을 의미합니다.</p>\n<p><code>500 Internal Server Error</code>는 서버의 코드나 설정에 문제가 있어서 정상적으로 요청을 처리할 수 없는 상태를 나타내는 대표적인 <code>5xx</code> 범주에 속하는 상태 코드인데요.\n클라이언트에서는 이 상태 코드를 받게 되면 서버 운영팀에 즉각 연락하여 빠른 조치가 될 수 있도록 도와주는 것이 좋습니다.</p>\n<p>서버 개발자가 의도적으로 <code>500</code> 상태 코드를 응답하도록 코드를 짤 수도 있지만,\n그 보다는 프레임워크 수준에서 의도치 않게 발생한 예외나 에러를 잡아서 자동으로 <code>500</code> 상태 코드를 응답해주는 경우가 더 많습니다.</p>\n<h2 id=\"503-service-unavailable\" style=\"position:relative;\"><a href=\"#503-service-unavailable\" aria-label=\"503 service unavailable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>503 Service Unavailable</h2>\n<p><code>503</code> 상태 코드는 <code>Service Unavailable</code>, 즉 서버가 일시적으로 서비스를 할 수 없는 상태를 의미합니다.</p>\n<p>이 상태 코드를 서버 개발자가 직접 사용할 일을 드믈고 주로 서버가 과부하 상태에 빠졌거나 유지보수를 위해 다운된 상태일 때, 미들웨어(middleware)나 컨테이너 오케스트레이션(Container Orchestration) 서비스에서 응답되는 경우가 많습니다.\n대표적인 예로 DDoS 공격을 받은 서비스가 <code>503 Service Unavailable</code>을 응답하는 경우를 들 수 있겠습니다.</p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>지금까지 웹 개발자로서 HTTP 상태 코드의 중요성을 상기하고 반드시 알고 있어야 하는 HTTP 상태 코드를 정리해보았습니다.</p>\n<p>사실 HTTP 스펙에는 이 것보다 훨씬 많은 상태 코드가 있지만 대부분 잘 안 쓰이지 않거나 스펙 상으로만 존재하는 경우가 많은데요.\n혹시 본 포스팅에서 다루지 않은 HTTP 상태 코드를 마주치신다면, <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\">관련 MDN 레퍼런스 문서</a>를 찾아보시면서 추가 학습을 하시면 좋을 것 같습니다.</p>\n<p>이 글이 HTTP 상태 코드를 올바르게 사용하는 데 있어서 많은 개발자분들에게 좋은 안내서가 되기를 바라며 이만 줄이겠습니다.</p>","timeToRead":9,"fields":{"slug":"/http-status-codes/","tags":["HTTP","response","status"]},"frontmatter":{"title":"웹 개발자를 위한 HTTP 상태 코드 안내서","date":"Jul 26, 2023"}},"next":{"fields":{"slug":"/meta-frameworks/"},"frontmatter":{"title":"메타 프레임워크 - 프레임워크를 위한 프레임워크"}}}},
    "staticQueryHashes": ["2168229929","2362167539","3056348342"]}