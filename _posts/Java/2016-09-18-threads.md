---
title: "쓰레드 객체"
modified: 2016-09-11T18:49:48+09:00
categories: 
  - Java
tags:
  - Concurrency
  - Process
  - Thread
published: true
---

> 본 포스트는 오라클 자바 튜토리얼의 [Thread Objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/threads.html)와 [Defining and Starting a Thread](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html), [Pausing Execution with Sleep](https://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html)를 번역하였습니다.


## 쓰레드 객체

모든 쓰레드는 `Thread` 클래스의 인스턴스와 관계를 갖습니다.
동시 어플리케이션(concurrent application)을 개발하기 위해서 쓰레드 객체를 사용하는데는 두 가지 기본 전략이 있습니다.

To directly control thread creation and management, simply instantiate Thread each time the application needs to initiate an asynchronous task.
To abstract thread management from the rest of your application, pass the application's tasks to an executor.
This section documents the use of Thread objects. Executors are discussed with other high-level concurrency objects.

- 쓰레드의 생성과 관리를 직접 제어하기 위해서, 어플리케이션이 비동기 작업이 필요할 때 마다 단순히 `Thread` 클래스의 인스턴스를 만들 수 있습니다.
- 응용 프로그램으로 부터 쓰레드 관리를 분리하고 추상화하기 위해서, 비동기 작업들을 `executor`에게 위임할 수 있습니다.

본 섹션은 `Thread` 객체의 사용에 대해서 문서화하겠습니다.
`Executors`는 고수준 동시성 객체(high-level concurrency objects) 섹션에서 별도로 다루겠습니다.


## 쓰레드를 정의하고 시작하기

`Thread` 인스턴스를 생성하는 응용 프로그램은 반드시 해당 쓰레드 상에서 수행될 코드를 제공해야 합니다.
다음과 같이 2가지 방법이 있습니다.


### `Runnable` 인터페이스를 구현하기

`Runnable` 인터페이스는 쓰레드 상에서 수행될 코드를 담기 위한 `run()`이라는 하나의 메서드만을 정의하고 있습니다.
다음 `HelloRunnalbe` 예제와 같이 `Runnalbe` 객체는 `Thread` 클래스의 생성자로 넘어오게 됩니다.

```java
public class HelloRunnable implements Runnable {

  public void run() {
    System.out.println("Hello from a thread!");
  }

  public static void main(String args[]) {
    (new Thread(new HelloRunnable())).start();
  }

}
```


### `Thread` 클래스를 상속하기

The Thread class itself implements Runnable, though its run method does nothing. An application can subclass Thread, providing its own implementation of run, as in the HelloThread example:

`Thread` 클래스 자체도 `Runnable` 인터페이스를 구현하고 있으나 `run()` 메소드는 아무 것도 하지 않도록 되어 있습니다.
다음 `HelloThread` 예제와 같이 `run()` 메소드에 대한 자체 구현을 제공함으로써 `Thread` 클래스를 상속할 수 있습니다.

```java
public class HelloThread extends Thread {

  public void run() {
    System.out.println("Hello from a thread!");
  }

  public static void main(String args[]) {
    (new HelloThread()).start();
  }

}
```


두 가지 예제 모두 새로운 쓰레드를 시작하기 위해서 `Thread.start()` 메소드를 호출하고 있다는 것에 주목하세요.

그럼 과연 어떤 방식을 사용해야 할까요? 
`Runnable` 인터페이스를 구현하면 `Thread` 클래스 외에 다른 클래스도 상속할 수 있기 때문에 `Runnable` 객체를 사용하는 첫번째 방식이 더 보편적입니다. 
두번째 방식은 간단한 어플리케이션에서 사용하기 더 쉽지만, 해당 작업 클래스가 `Thread` 클래스의 후손이 되어야 한다는 제한이 있습니다.
본 수업에서는 `Runnable` 작업을 그 작업을 실행시켜주는 `Thread` 객체로부터 분리하여 접근하는 첫번째 방식에 초점을 맞추겠습니다.
이러한 접근법이 더 유연한 뿐만 아니라, 나중에 다룰 고수준의 쓰레드의 관리 API에서도 더 적용이 용이합니다.

`Thread` 클래스는 쓰레드 관리를 위한 많은 메소드를 정의하고 있습니다. 
이 메소드들은 해당 메소드를 호출하는 대상 쓰레드와 관련된 정보를 제공거나 대상 쓰레드의 상태에 영향을 주는 정적 메소드를 포함합니다.
다른 메소드들은 해당 쓰레드와 `Thread` 객체를 관리하는데 관여하고 있는 다른 쓰레드로 부터 호출되어집니다.
이어지는 섹션에서 이 메소드들을 살펴보도록 하겠습니다.


## `Sleep`으로 실행 중지하기

`Thread.sleep()` 메소드는 현재 쓰레드가 일정 기간동안 실행을 중지시킵니다.
이 것은 해당 어플리케이션 또는 시스템 상에서 돌고 있는 다른 어플리케이션 내의 다른 쓰레드들에게 프로세서를 이용 가능하도록 만들기 위한 효율적인 방법입니다.
`sleep()` 메소드는 다음 예제와 같이 속도 조절을 위해서도 사용될 수 있습니다.
또한 다음 섹션의 `SimpleThreads` 예제와 같이 대기 요건이 용납되는 임무를 가진 또 다른 쓰레드를 기다리기 위해서도 사용될 수 있습니다.

`sleep` 메소드는 오버로드된 두가지 버전이 제공되는데 하나는 밀리 초단위로 정지 시간을 지정할 수 있고 다른 하나는 나노 초단위로 정지 사간을 지정할 수 있습니다.
하지만 이 정지 시간은 기저 운영체제의 제한을 받기 때문에 정확하게 보장되지 않습니다. 
또한 정지 시간은 다음 섹션에서 보시겠지만 인터럽트에 의해서 종료될 수 있습니다.
어떤 방식으로든지 `sleep` 메소드를 호출하는 것이 정확하게 지정한 기간 만큼 쓰레드를 중지시킬 것이라고 가정할 수는 없습니다.

다음 `SleepMessages` 예제는 4초 간격으로 메세지를 출력하기 위해서 `sleep()` 메소드를 사용하고 있습니다.

```java
public class SleepMessages {
  public static void main(String args[]) throws InterruptedException {
    String importantInfo[] = {
      "Mares eat oats",
      "Does eat oats",
      "Little lambs eat ivy",
      "A kid will eat ivy too"
    };

    for (int i = 0; i < importantInfo.length; i++) {
      //Pause for 4 seconds
      Thread.sleep(4000);
      //Print a message
      System.out.println(importantInfo[i]);
    }
  }
}
```

`main` 메소드가 `InterruptedException`을 던지도록 정의되어 있다라는 점을 점을 주목하세요.
이 것은 `sleep` 메소드가 실행 중에 다른 쓰레드가 현재 쓰레드를 인터럽트하면 `sleep` 메소드가 던지는 예외입니다.
본 어플리케이션에서는 인터럽트를 유발하는 다른 쓰레드를 정의하지 않았기 때문에, 굳이 `InterruptedException` 예외를 잡으실 필요는 없습니다.